#This example nginx config serves what is requested to real browsers (or 404 if not found)
#But it serves /usr/share/nginx/html/bot.html to bots.
#Be careful: If that file is not available, it will serve bots the real content !

#To test run "curl -v http://localhost:8000/some/page.html" and you should see that it always serves the content of /bot.html instead of the requested file.
#("localhost:8000" because this is where nginx will listen when launched with the docker script)
#Just like a real bot you should see nothing about the contents being at /bot.html in the traffic (it's not a redirect) and you should get a 200 OK response.
#This means that a bot will have no idea that it's being served a different page

#A 'evil' bot that sets it's user agent to that of a real browser will still get the real content.
#You can see this with (for example): "curl -v -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3" http://localhost:8000/some/page.html"

#If $is_a_bot is 1, then $botpage will be /bot.html, otherwise it will be empty
map $is_a_bot $botpage {
    default "";
    1 "/bot.html";
}

server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    root   /usr/share/nginx/html;

    location / {
        #Because for real browsers $botpage is empty, it will just try to serve the requested file
        #But for bots it's /bot.html so it will immediately serve that without trying the other options
        try_files $botpage $uri $uri/ =404;
    }
        
}
